(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{522:function(v,_,e){"use strict";e.r(_);var t=e(3),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"redis缓存雪崩-击穿-穿透"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis缓存雪崩-击穿-穿透"}},[v._v("#")]),v._v(" Redis缓存雪崩,击穿,穿透")]),v._v(" "),e("p",[e("strong",[v._v("缓存雪崩")])]),v._v(" "),e("p",[v._v("大量缓存key在"),e("code",[v._v("同一时间失效")]),v._v("，大量请求直接落在数据库上，导致数据库宕机。")]),v._v(" "),e("p",[e("strong",[v._v("解决方案")])]),v._v(" "),e("ul",[e("li",[v._v("随机设置key失效时间，避免大量key集体失效。")])]),v._v(" "),e("p",[e("strong",[v._v("缓存穿透")])]),v._v(" "),e("p",[v._v("redis中没有这样的数据，"),e("code",[v._v("无法进行拦截")]),v._v("，直接被穿透到"),e("code",[v._v("数据库")]),v._v("，导致数据库压力过大宕机。")]),v._v(" "),e("p",[e("strong",[v._v("解决方案")])]),v._v(" "),e("ul",[e("li",[v._v("对不存在的数据缓存到redis中，设置key，value值为null(不管是数据未null还是系统bug问题)，并设置一个短期过期时间段，避免过期时间过长影响正常用户使用。")]),v._v(" "),e("li",[v._v("对参数进行校验，不合法参数进行拦截")]),v._v(" "),e("li",[v._v("布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap(位图)中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。")])]),v._v(" "),e("p",[e("strong",[v._v("缓存击穿")])]),v._v(" "),e("p",[e("code",[v._v("某一个")]),v._v("热点key，在不停地扛着高并发，当这个热点key在"),e("code",[v._v("失效的一瞬间")]),v._v("，持续的高并发访问就"),e("code",[v._v("击破缓存")]),v._v("直接访问数据库，导致数据库宕机。")]),v._v(" "),e("p",[e("strong",[v._v("解决方案")])]),v._v(" "),e("ul",[e("li",[v._v('设置热点数据"永不过期"')]),v._v(" "),e("li",[v._v("加上互斥锁：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它，其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后将数据放到redis缓存起来。后面的线程进来发现已经有缓存了，就直接走缓存")])]),v._v(" "),e("p",[e("strong",[v._v("最后总结")]),v._v("\n雪崩是"),e("code",[v._v("大面积")]),v._v("的key缓存失效；穿透是redis里"),e("code",[v._v("不存在")]),v._v("这个缓存key；击穿是redis"),e("code",[v._v("某一个热点")]),v._v("key突然失效，最终的受害者都是数据库。")])])}),[],!1,null,null,null);_.default=s.exports}}]);